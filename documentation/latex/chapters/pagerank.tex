\section{PageRank}

\subsection{Pseudocode}
\begin{algorithm}[H]
	\caption{PageRank}\label{General}
		\begin{algorithmic}[1]
			
			\Procedure{Counting Nodes}{dataset d}
				\State $N \gets d.countNodes()$
				\State \Return N
			\EndProcedure
\newline			
			\Procedure{Graph Construction - Parsing}{dataset d}
				\State nodesList \textit{new} \textbf{AssociativeArray}
				\ForAll {page \textit{in} d}
					\State $title \gets page.getTitle()$
					\State $outgoingEdges \gets page.getOutgoingEdges()$
					\State $nodeLists.add(\{ title, outgoingEdges\}) $
				\EndFor
				\State \Return nodesList
			\EndProcedure
	\newline		
			\Procedure{Compute PageRank}{nodesList NL, numberOfNodes N, nOfIterations NI}
				\State $NL.addInitPageRankToNodes(\frac{1}{N})$
				
				\For { i \textbf{in} range(NI)}
					\State NL.Map()
					\State NL.Reduce()
				\EndFor
				\State NL.sortByPagerank()
				
			\EndProcedure
\newline
			\Procedure{Map}{title t, \{outgoingEdges oe, pagerank p\}}
				\ForAll {e \textbf{in} oe}
					\State EMIT(e, $\frac{p}{oe.length}$)
				\EndFor
			\EndProcedure
						
			\Procedure{Reduce}{title t, pagerankContributions [$p_1, p_2, \dots $]}
				\State $damping \gets 0.8$
				\State $sum \gets 0$
				\State $N \gets numberOfNodes$
				
				\ForAll p \textbf{in} pagerankContributions
					\State $sum \gets sum + p$
				\EndFor
				
				\State $pagerank =  \frac{(1-damping)}{N} + damping*sum$
				\State EMIT(t, pagerank)
			\EndProcedure
	\end{algorithmic}
\end{algorithm}

\subsection{Introduction}
In this section a description of the MapReduce implementation of \textit{Page Rank} is given.
The algorithm is carried out in \textbf{three distinct steps}:
\begin{enumerate}
	\item \textit{Graph Construction} phase
	\item \textit{Page Rank Computation} phase
	\item \textit{Sorting} phase
\end{enumerate}

\noindent We have decided to represent the structure of the graph through adjacency lists, so each node (that represents a page) will keep the list of outgoing edges as status information, as well as its ranking.

\subsection{First Phase: Graph Construction}
In this phase we parse the information in the input file taking the information that interests us, i.e. the title of the page and the outgoing edges. In addition to this, we take advantage of this phase to also perform the count of the graph nodes.

\begin{algorithm}[H]
	\caption{Graph Construction Mapper}\label{Mapper}
		\begin{algorithmic}[1]
			\Procedure{Map}{PageId id, Page p}
					\State $\textit{title} \gets \textit{getTitle(p)}$
					\State $ outgoingEdges \gets \textit{getOutgoingEdges(p)}$
		
					\State EMIT(title, outgoingEdges)
			\EndProcedure
			
			
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
	\caption{Graph Construction Reducer}\label{Reducer}
		\begin{algorithmic}[1]
			\Procedure{InitReduce}{Configuration c}
				\State $N \gets c.numberOfNodes$
			\EndProcedure
		
			\Procedure{Reduce}{Title t, ListOfListOfEdges $[e_1, e_2, \dots]$}
					\State $\textit{initialPageRank} \gets \frac{1}{N} $
					\State $ \textit{edges} \gets e_1$
		
					\State EMIT(title, \{initialPageRank, edges\})
				
			\EndProcedure
		\end{algorithmic}
\end{algorithm}

\noindent In \textit{Algorithm 4} only $e_1$ is considered because the title is a unique identifier of the pages, so the list of input values will always consist of a single element. Only one mapper will manage one page.

\subsection{Second Phase: PageRank Estimation}
In this section, the pagerank iteration is presented.
\noindent The number of iteration is fixed at the start of the execution. We do not converge to a (or a more or less) consistent state, because the presence of dangling nodes will cause importance (i.e., pagerank mass) to leak out.

\begin{algorithm}
	\caption{PageRank Computation Mapper}\label{Mapper}
		\begin{algorithmic}[1]
						\Procedure{Map}{Key k, FormattedPage p}
			
			\State EMIT(p.title, \{0, p.outgoingEdges\})
			\ForAll{outgoingEdge \textbf{in} p.outgoingEdges}
			\State EMIT(outgoingEdge, $\{\frac{p.pagerank}{p.outgoingEdges.length}, NULL\}$)
			\EndFor
			\EndProcedure
	\end{algorithmic}
\end{algorithm}
Note: \textit{outgoingEdge} is a title itself.


\begin{algorithm}[H]
	\caption{PageRank Computation Reducer}\label{Reducer}
		\begin{algorithmic}[1]
			\Procedure{InitReduce}{Configuration c}
				\State $N \gets c.numberOfNodes$
				\State $D \gets Damping$
			\EndProcedure
		
			\Procedure{Reduce}{Title t, Nodes $[n_1, n_2, \dots]$}
					\State n \textbf{new} Node
					\ForAll {node \textbf{in} nodes}
						\If {node.hasOutgoingEdges()}
							\State n.outgoingEdges = node.outgoingEdges
						\Else
							\State $s = s + node.pagerank$
						\EndIf
					\EndFor
					\State$n.pagerank =  \frac{(1-D)}{N} + D*s$
					\State EMIT(t, n)
			\EndProcedure
	\end{algorithmic}
\end{algorithm}



\subsection{Third Phase: Sorting}
The final step is sorting the webpages by decreasing rank, this is done making advantage of the sorting mechanism of MapReduce.

\begin{algorithm}[H]
	\caption{Sorting Mapper}\label{Mapper}
	\begin{algorithmic}[1]
		\Procedure{Map}{Key k, FormattedPage p}
		\State $title \gets p.title$
		\State $pagerank \gets p.pagerank$k
		\State EMIT(pagerank, title)
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
	\caption{Sorting Reducer}\label{Reducer}
	\begin{algorithmic}[1]
		\Procedure{Reduce}{Pagerank rank, Titles $[t_1, t_2, \dots]$}
		\ForAll {title \textbf{in} titles}
		\State EMIT(title, rank)
		\EndFor
		\EndProcedure
	\end{algorithmic}
\end{algorithm}
