\section{PageRank}

\subsection{Introduction}
In this section a description of the MapReduce implementation of \textit{Page Rank} is given.
The algorithm is carried out in \textbf{four distinct steps}:
\begin{enumerate}
	\item \textit{Nodes counting} phase
	\item \textit{Graph Construction} phase
	\item \textit{Page Rank Computation} phase
	\item \textit{Sorting} phase
\end{enumerate}


\noindent We have decided to represent the structure of the graph through adjacency lists, so each node (that represents a page) will keep the list of outgoing edges as status information, as well as its ranking.



\subsection{First Phase: Nodes Counting}
To compute PageRank the total number of nodes is required. Considering that the number of nodes is unknown at the beginning –and may be huge–, this is assessed by using a MapReduce approach for optimization reasons.


\begin{algorithm}[H]
	\caption{Nodes Counter Mapper}\label{Mapper}
		\begin{algorithmic}[1]
			\Procedure{Map}{PageId id, Page p}
					\If {p is not empty}
						\State EMIT(uniqueKey, 1) 
					\EndIf
			\EndProcedure
	\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]
	\caption{Nodes Counter Reducer}\label{Reducer}
		\begin{algorithmic}[1]
			\Procedure{Reduce}{Key k, Values $[v_1, v_2, \dots]$}
					\ForAll {value \textbf{in} values}
						\State $sum \gets sum + value$
					\EndFor
					\State EMIT(N, sum)
			\EndProcedure
	\end{algorithmic}
\end{algorithm}


\subsection{Second Phase: Graph Construction}
In this phase we parse the information in the input file taking the information that interests us, i.e. the title of the page and the outgoing edges. Also, to each page, we provide the initial PageRank thanks to the already calculated total number of nodes. 

\begin{algorithm}[H]
	\caption{Graph Construction Mapper}\label{Mapper}
		\begin{algorithmic}[1]
			\Procedure{Map}{PageId id, Page p}
					\State $\textit{title} \gets \textit{getTitle(p)}$
					\State $ outgoingEdges \gets \textit{getOutgoingEdges(p)}$
		
					\State EMIT(title, outgoingEdges)
			\EndProcedure
			
			
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
	\caption{Graph Construction Reducer}\label{Reducer}
		\begin{algorithmic}[1]
			\Procedure{InitReduce}{Configuration c}
				\State $N \gets c.numberOfNodes$
			\EndProcedure
		
			\Procedure{Reduce}{Title t, ListOfListOfEdges $[e_1, e_2, \dots]$}
					\State $\textit{initialPageRank} \gets \frac{1}{N} $
					\State $ \textit{edges} \gets e_1$
		
					\State EMIT(title, \{initialPageRank, edges\})
				
			\EndProcedure
		\end{algorithmic}
\end{algorithm}

\noindent In \textit{Algorithm 4} only $e_1$ is considered because the title is a unique identifier of the pages, so the list of input values will always consist of a single element. Only one mapper will manage one page.

\subsection{Third Phase: PageRank Estimation}
In this section, the relaxed pagerank iteration is presented.
\noindent The number of iteration is fixed at the start of the execution. We do not converge to a (or a more or less) consistent state, because the presence of dangling nodes will cause importance (i.e., pagerank mass) to leak out.

\begin{algorithm}
	\caption{PageRank Computation Mapper}\label{Mapper}
		\begin{algorithmic}[1]
						\Procedure{Map}{Key k, FormattedPage p}
			
			\State EMIT(p.title, \{0, p.outgoingEdges\})
			\ForAll{outgoingEdge \textbf{in} p.outgoingEdges}
			\State EMIT(outgoingEdge, $\{\frac{p.pagerank}{p.outgoingEdges.length}, NULL\}$)
			\EndFor
			\EndProcedure
	\end{algorithmic}
\end{algorithm}
Note: \textit{outgoingEdge} is a title itself.


\begin{algorithm}[H]
	\caption{PageRank Computation Reducer}\label{Reducer}
		\begin{algorithmic}[1]
			\Procedure{InitReduce}{Configuration c}
				\State $N \gets c.numberOfNodes$
				\State $D \gets Damping$
			\EndProcedure
		
			\Procedure{Reduce}{Title t, Nodes $[n_1, n_2, \dots]$}
					\State n \textbf{new} Node
					\ForAll {node \textbf{in} nodes}
						\If {node.hasOutgoingEdges()}
							\State n.outgoingEdges = node.outgoingEdges
						\Else
							\State $s = s + node.pagerank$
						\EndIf
					\EndFor
					\State$n.pagerank =  \frac{(1-D)}{N} + D*s$
					\State EMIT(t, n)
			\EndProcedure
	\end{algorithmic}
\end{algorithm}



\subsection{Fourth Phase: Sorting}
The final step is sorting the webpages by decreasing rank, this is done making advantage of the sorting mechanism of MapReduce.

\begin{algorithm}[H]
	\caption{Sorting Mapper}\label{Mapper}
	\begin{algorithmic}[1]
		\Procedure{Map}{Key k, FormattedPage p}
		\State $title \gets p.title$
		\State $pagerank \gets p.pagerank$k
		\State EMIT(pagerank, title)
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
	\caption{Sorting Reducer}\label{Reducer}
	\begin{algorithmic}[1]
		\Procedure{Reduce}{Pagerank rank, Titles $[t_1, t_2, \dots]$}
		\ForAll {title \textbf{in} titles}
		\State EMIT(title, rank)
		\EndFor
		\EndProcedure
	\end{algorithmic}
\end{algorithm}
